
QIU Memory Manager 1.14 for Delphi
简称：QMM

描述:
	一个简单的内存管理器for Delphi/XE

主页:
  https://code.google.com/p/qiumm/
  by qiusonglin (qiusonglin.hex@gmail.com)

如何应用到工程:
 - 如同其它MM，将它放置于dpr最上面即可使用

其它注意事项:
 - 注意：QMM在D7+D2010+XE4+XE6(WIN32+WIN64)测试通过，其它Delphi版本请自行测试，WIN64测试不全面，可能会有问题
 - 支持多线程，为每线程分配一线程管理器，所以，它是并行分配内存的。
 - 更多，请看readme.txt & change.log

技术支持:
  如在使用QMM遇到问题，欢迎来信，如果有BUG或更好的建议更是欢迎:)

License:
  Released under Mozilla Public License 1.1

  If you find QMM useful or you would like to support further development,
  a donation would be much appreciated.
  My PayPal account is: qiusonglin.hex@gmail.com

--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------

QMM文档组成:
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
QMM.pas - 用于替换D自带的MM，用于加速你的内存管理
QMM.inc - 配置文件
--------------------------------------------------------------------------------------------------------------------------
QMM配置中的可选项(QMM.Inc):
--------------------------------
废弃：fastcode - 是否使用fastcode代码, 用于代替系统函数：fillchar and move.
					 该系统函数未像其它MM样，集成到QMM中，进行优化，直接使用fastcode

1: debug release  - 它与应用工程相同

2: 其它宏TRACE_STACK，它可以单独关闭或打开（只限于debug模式）
如果打开，得到的泄露报告是的数据展现如下：
--------------------------------
leak X:
stack trace: $4097E4 -> $4D372C -> $4D3250 -> $4D3FE1 -> $4D4379 -> $0 -> $0 -> $0
unknow data: $3C0492C, size: 53, data: 

--------------------------------------------------------------------------------------------------------------------------

QMM.pas - 替换Delphi的内存管理器

1: 常量
   StackTraceDepth = 8;
   -- （for debug）用于跟踪指针申请时，回溯调用数量，默认8，一般够用，可修改，但不建议太多，因为它在每个指针申请都会分配。
   suffix_mem_check = sizeof(Pointer) * 2;
   -- (for debug) 该常量用于检测越界形为时，检查的内存块的长度，如定义了N字节，则检查该N字节是否给改写（越界改写），
      如果改写，则回调on_memory_error_proc或中断（调试环境）
   -- 没了.
   
2: Variable:
  on_memory_error_proc: procedure(op: TDebugMemOP; address: Pointer; size: MSIZE);  
  -- 当此回调给赋值，则内存检查失败后会回调
		(请查看DEMO示例)

  int3_when_memory_error: Boolean = true;
  -- 没啥用的变量，只是为了在调试环境下，如果出现大量错误时，别老是中断，让程序继续运行。
  
  on_notify_get_proc,  on_notify_realloc_proc,  on_notify_free_proc
  -- 其它回调事件变量，只是为了接口，没啥说的。
  
3: 如果未定义debug与release其中之一，则默认自定义:release
   
  
3: 新增单元t: QMMErrorUtils.pas
   一个工具单元，用于：当内存越界后，将该内存指针以日志形式写入到文件。
   你可以通过配置下列两个常量值，进行越界检查：
		StackTraceDepth & suffix_mem_check
	具体事例，请参考demo\mem-error

--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------

NOTE: 
  1: 当变量ReportMemoryLeaksOnShutdown= true,  QMM将会报告内存泄露情况（如果有泄露，且无论是debug或release模式）
  2：如果与单元QMMErrorUtils.pas使用，当内存错误出现时，则QMM将会立即报告错误到文件中
      错误日志目录: YourApp\mem-error\YourApp.threadId.txt
        
注意：当系统变量System.ReportMemoryLeaksOnShutdown=true，并且为DEBUG模式，
			如果发生内存泄露，QMM将会生成一个文件：memory.leak.txt进行报告该问题

好了，其它问题，有需要请邮给我
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
2014.07.21 by qiusonglin 



		  
		  


