170=Zsserver4d is a server middleware. This demo only demonstrates basic link communication processing
171=The attached client can be a mobile platform or a personal computer platform
176= Reverse is the reverse automated p2pvm model. See 31. Related demo of reverse p2pvm 
177= The communication tunnel driven by p2pvm can be set with various similar dual channel, database and file transmission applications. See the relevant demo of VM 
178= Automated p2pvm is a very simplified p2pvm application paradigm, which has the ability to drive the p2pvm framework with very short code 
179= Automated P2P VM is also the communication foundation of ECS 3.0 
182=Dual channel minimalist framework based on p2pvm
191=Listening port succeeded: %d
197= Txnatclient can be deployed to the main project, which only uses less than 10 %of the CPU of the main project
If multiple public network servers need to penetrate, you can create multiple txnatclients 
198= Penetration protocol compression options
Recommended usage scenarios:
If the agent's data has been compressed or encrypted using HTTPS, the compression will be invalid, and even the compressed data will be larger
If it is a bare data protocol, such as FTP, HTTP without s, TenneT, the compression switch can be turned on and the speed can be increased slightly 
199= IP address of public network server 
200= Port number of public network server 
201= Protocol Validation string 
202= 127.0.0.1 is the IP address of the intranet server 
203= Reverse proxy port 8000 of the public server to port 80 of the local server 
204= Start intranet penetration 
205=Completed: %d
206=The compute thread has finished safely. Press enter to exit
207= This demo demonstrates the programming paradigm that thread 2 sends data to thread 1 and processes it 
208= The tcriticalorderstruct sequence structure is thread safe 
209= If you use the FPC compiler, declaring generics requires the specify prefix 
211= Add compiler judgment here to declare 
215=Address:
217=link
218=expression:
220=calculation
222=At TDT_ P2PVM_ NoAuth_ Avoid using blocking network mechanism in TDT in client_ P2PVM_ NoAuth_ Try to use asynchronous events in the client
226=One way server framework demo
227=one-way
228=Use Indy as the demo of the server on the mobile phone
233=1. Avoid using blocking network mechanism
234=2. Try to use asynchronous events in
235=3. The virtuaauth server accepts all login users and passwords
236=4. Automation supports short-term reconnection
238=Zsserver4d is a server middleware. This demo only demonstrates the processing mechanism of delayed response
239=After the delayresponse command is executed, it will not give feedback to the client immediately
240=The delay response mechanism is implemented by state machine. Once the response stops, the instructions in the queue will be in the waiting state. The delay mechanism is mainly used for cross server communication or nonlinear process
243=Zsserver4d is a server middleware. This demo demonstrates the processing mechanism of delayed response using anonymous functions
246= When we are in freelibrary, any call using syncevent will get stuck 
247= Open debug and trace out two places where syncevent is used 
248= Find a place to use syncevent for synchronization, and we can slowly catch up in the finalization event 
249= The interface of crosssocket has a clientpool, which is released during finalization and will use syncevent 
257=The dual channel construction is completed
268=3. Automation supports short-term reconnection
270=Directly map to local server demo based on xnatservice protocol
271=Principle:
272=Xnatservice is a public network server that listens on one or more specified ports on the public network
273=Lannatvirtualserver is based on xnatclient protocol and directly maps xnatservice to local service
274=Using the name in the replacement project, the framework can drive tens of thousands of physical connections in mobile phone platform and arm based IOT platform
281= The public network server of xnat is used for the public network protocol interface
The mobile server of xnat is a server model that works on mobile phones or IOT devices
In the public network protocol interface, xnat uses P2P VM technology to demonstrate how to make mobile phones carry a large number of physically connected services
The maximum physical concurrent connection limit for xnat is 4000 
282= Penetration protocol compression options
Recommended usage scenarios:
If the agent's data has been compressed or encrypted using HTTPS, the compression will be invalid, and even the compressed data will be larger
If the time raw data protocol, such as FTP, HTTP without s, TenneT, the compression switch can be turned on and the speed can be increased slightly
Performance optimization idea: zlib's compression algorithm is characterized by slow compression and very fast decompression. The server does not compress the data when sending it, and the client compresses all the data sent
Adjust SendTunnel.CompleteBufferCompressed:=False in TXServiceListen instance;
Adjust SendTunnel.CompleteBufferCompressed:=True in TXClientMapping instance;
In txnat_ SendTunnel.CompleteBufferCompressed:=True is adjusted in MappingOnVirutalServer instance. 
283= Communication parameters with intranet server: the protocol tunnel binding address is IPv4 of all network cards. If it is IPv6, write '::' 
284= Communication parameters with intranet server: protocol port 
285= Communication parameters with intranet server: protocol verification string (the identifier uses anti quantum cryptography model, please study the code by yourself for related technologies) 
286= Listening configuration 
287= Port 8000 needs to be mapped on the server side, and the binding address is IPv4 of all network cards. Because the user-defined service of long connection is mounted, the socket will be automatically released when the connection is idle for 10 minutes and times out 
288= Penetration protocol compression options
Recommended usage scenarios:
If the agent's data has been compressed or encrypted using HTTPS, the compression will be invalid, and even the compressed data will be larger
If it is a bare data protocol, such as FTP, HTTP without s, TenneT, the compression switch can be turned on and the speed can be increased slightly 
290=This demo demonstrates how to use the ZS client in a thread
297=Testing of various MD5 algorithms
299=Hash file
302=Hash string
308= Penetration protocol compression options
Recommended usage scenarios:
If the agent's data has been compressed or encrypted using HTTPS, the compression will be invalid, and even the compressed data will be larger
If it is a bare data protocol, such as FTP, HTTP without s, TenneT, the compression switch can be turned on and the speed can be increased slightly
Performance optimization idea: zlib's compression algorithm is characterized by slow compression and very fast decompression. The server does not compress the data when sending it, and the client compresses all the data sent
Adjust SendTunnel.CompleteBufferCompressed:=False in TXServiceListen instance;
Adjust SendTunnel.CompleteBufferCompressed:=True in TXClientMapping instance;
In txnat_ SendTunnel.CompleteBufferCompressed:=True is adjusted in MappingOnVirutalServer instance. 
309= Port 8000 needs to be mapped on the server side, and the binding address is IPv4 of all network cards. Because the HTTP of the short connection is attached, the socket will be automatically released when the connection is idle for 1 minute and times out 
310= When the intranet server is not connected, temporarily disconnected, and mapping "ftp8021" is not requested, the 8021 port is in a non listening state. This 8021 will start to work only when all the intranet servers are working normally 
311= On the server side, the port 8021 to be mapped is bound to the IPv4 address of all network cards. Because the FTP with a long connection is mounted, the socket will be automatically released when the connection is idle for 15 minutes and times out 
313=Wildcards are special statements, mainly asterisks (*) and question marks (?), used to blur search files. When looking for a folder, you can use it instead of one or more real characters; Wildcards are often used instead of one or more real characters when you don't know the real characters or are too lazy to enter the full name.
314=*Can represent any string;? Represents only a single string, but this word must exist
315=Umlmultiplematch is a wildcard string matching function
324= The stream instruction is sent asynchronously and received, and the feedback is triggered by proc callback 
335=3. The virtuaauth server accepts all login users and passwords. Even if there is no user, it will accept. The default login user name is testuser and password is tes
339=Complete a cycle
340=Wait for the cycle to complete
341=Press enter to end the program
342= A simple demonstration of using a safe state machine in a thread 
343= Thread safety: state variables 
344= Worker thread 
345= Change state variable 
346= Simple demonstration of using post mechanism in thread 
347= Post is equivalent to sending code to a target thread we build for execution. Post does not select linear types, does not distinguish between main threads / sub threads, and can be used by any thread 
348= Tthreadpost, post mechanism support 
349= The local variable will be automatically destroyed after the call is completed. Therefore, we must do a monitoring work here_ End state 
350= Post main loop 
351= Send task to worker thread 
352= These tasks are performed in strict order of input 
353= End of worker thread 
354= After execution 
362=Fill indicates the memory filling operation, fillptr is the basic library support API, and fillchar is the Delphi / FPC built-in support API
363=Copy refers to memory copy operation, copyptr is the basic library support API, and move is the Delphi / FPC built-in support API
364=Because fill and copy are related to the performance of communication, graphics, statistics, AI and other advanced libraries, I wrote this demo
365=Since the processes are all VM mechanisms, the test fill operation needs to distinguish between the initial speed and the take-off speed. The initial speed indicates that fill is executed for the first time, and the take-off speed indicates that fill is executed for the second time,
366=The takeoff speed also represents the normal speed. The fill test is calculated as the second time
367=The copy operation does not need to distinguish between the initial speed and takeoff speed. This demo is a single line operation and only describes the basic library API. This demo cannot represent the hardware capability. Do not use this demo to evaluate the hardware
369=Waiting...
376=Zsserver4d is a server middleware. The demo is a login two-way mode (a method to interface with a large authentication background)
390=Orderstruct is a sequence structure driven framework located in the kernel library. Its idea is based on the push / pop of assembly language
391=Orderstruct gets rid of the influence of linked list and array, and directly accesses the structure. In the queue mechanism and parallel programs, the performance and simplicity are better than linked list
392=TOrderStruct<T_>밐 Example of general sequence structure framework, < t_ > It can be a class, a record, or an atomic variable
393=TOrderPtrStruct<T_>밐 Sequence structure framework instance of automation pointer, < T > If the record / atomic variable, it will be automatically converted to a pointer
394=Manage memory
395=TCriticalOrderStruct<T_>밐 (thread safe) general sequence structure framework instance, < T > It can be a class, a record, or a
396=Therefore, atomic variables are the preferred data queue framework for parallel / multiline programs
397=TCriticalOrderPtrStruct<T_>밐 (thread safety) sequence structure framework instance of automation pointer, < T > If record / original
398=Sub variables will be automatically converted into pointers to automatically manage memory
399=Orderstruct is currently widely used in parallel and multithreaded data optimization in the background of AI
413=Listening succeeded
415=Zsserver4d is a server middleware, and the demo is in two-way mode
416=The two-way mode interpretation can be explained by the client actively sending commands to the server for execution or the server actively initiating command execution to the client. In the link mechanism, two channels are used, one for receiving and one for sending. When both channels are successfully linked, the two-way bridge can be completed by using the tunnellink method
417=The command system can be a simple string and various data packages, or a stream package. In short, any data transceiver lower than 500K, including small files, can use the command
418=When the data length is very large, the bigstream mechanism must be used in zsserver4d to send and receive data
421=Multi line file download demo
422=The demo demonstrates multi line file download (similar to Xunlei)
423=The multi line download mechanism of the demo is the standard mechanism. Look at the code more, especially the data structure design. The transmission mechanism of the demo is completebuffer, which needs to control the memory overhead
424=The demo server will not temporarily store all files. The file data temporarily stored by the server depends on the download thread. It will not explode
426=Create 10 physical connections
427=Multithreaded Download
429=Standard server paradigm for making external customized protocols. Based on this paradigm, we can develop our own FTP, HTTP and other protocols, and develop our own external protocols based on ZS, which can naturally support high concurrency and cloud background
430=The external protocol developed based on ZS is mainly compatible with other three-party communication terminals. Therefore, the client needs to solve it by itself. For example, Indy is selected as the communication client
440=HPC background computing server demonstration
441=The server resource time occupied by background operation is zero
442=HPC background demonstration is very suitable for large-scale computing needs
443=The technical mechanism mainly focuses on the large-scale operation on the server side. When the server receives a streamcmd command, the traditional processing method is that the server is blocked in the processing command, and other requests are waiting. We don't let the server block at this moment. We use the delay technology to tell the background to suspend feedback
445=Then, we start a background thread and let the background continue to feed back after the thread execution is completed
447=In the HPC background demonstration program, the above process is automated. It is very simple to use. Using this mode, you can accumulate code indefinitely
449= In the process of accessing other servers, the user waiting for authentication may be disconnected, so we need to judge 
450= Bye in tvirtualuthio is equivalent to free. If we don't bye, it will cause memory leakage 
451= The accept and reject methods in tvirtualuthio can only be called once and will be automatically released after completion 
452= Accept user login 
453= Deny user login 
454= Tvirtualuthio has two working modes 
455= The first is to authenticate immediately and write the implementation directly below 
456= if SameText(Sender.UserID, 'Test') and SameText(Sender.Passwd, 'Test') then
Sender. Accept / / accept user login
else
Sender.Reject; //  Deny user login 
457= The second working mode is delayed authentication. In the second mode, we don't have to do anything. Save the instance of tvirtualuthio. After the remote authentication is completed, we will feed it back to the client 
459=Data before dataframeengine encryption: %s
461=Successfully decrypted
462=Password error
463=Dataframeengine decrypted data: %s
464=Data before buffer encryption: %s
465=Data decrypted by buffer: %s
466= This function demonstrates how anti quantum cryptography can be used in tdataframeengine 
467= ZS's dataframeeninge can use this method for encryption before sending and receiving 
468= Note: the performance of anti quantum cryptography cannot achieve real-time, so we can choose to encrypt some important data 
469= Generate the key of Rijndael encryption algorithm with the password "password123456" 
470= Then, the buffer is encrypted 1024 times by Rijndael encryption algorithm 
471= The password will be encoded in 3-512 bits twice 
472= Why is this anti quantum cracking? 
473= Because Sha3 is quantum design, and the secure password ensures that multiple Rijndael encryption is secure 
474= Under the dual security mechanism, encrypt method can resist future quantum attacks 
475= Without knowing the password, the data in M64 can never be decrypted 
476= This function demonstrates how to resist quantum encryption and decryption of stream data 
477= Stream can be used for ZS's completebuffer, bigstream, batchstream and other mechanisms 
483= Here is a demonstration of how HPC can load large-scale computing 
484= The NOP function is in the main thread section 
485= RunHPC_ When streamp is called, IO pauses feedback and immediately sends the request to the child thread for execution 
486= RunHPC_ Streamp is scheduled by HPC's dedicated kernel thread pool and is safely scheduled, not Delphi / FPC's built-in thread pool 
487= The following code is executed in the thread section 
488= Dropping data into thoutdata means that feedback is required. Here is the expression time of the number of num feedback execution 
489= After this step is completed, IO will resume feedback 
490= : equivalent to 0:0:0:0:0:0 is a virtual IPv6 in p2pvm, not a real physical address. This address can be given arbitrarily 
491= 88:: equivalent to 88:0:0:0:0: 0 is a virtual IPv6 in p2pvm, not a real physical address. This address is given arbitrarily 
492= Registration instruction 
496=Delphi / FPC built-in compressor (zlib)
497=LZ77 + Huffman compressor (deflate)
498=Gradient compressor (BRRC)
499=MH memory allocation test, please use your mobile phone
501= Torderptrstruct will automatically convert tmyrecord to pointer 
502= This structure is suitable for simple record 
503= Torderptrstruct has its own release mechanism, which is convenient for demonstration. Here is an inheritance operation to release the interface event and release tmyrecord - > obj 
504= Push tmyrecord data into the queue 
505= Push copies TMP back to a memory block 
506= By avoiding the use of linked lists and arrays, the push operation is very fast and can support highly intensive calls, such as 100 million times per second 
507= Push has no size limit, and the push mechanism can last until the memory is used up 
508= There are two ways to obtain data: 1. Directly judge whether current is nil 
509= Next frees the current structure, frees memory, and points to the next structure 
510= There are two ways to obtain data: 2. Judge the current queue num 
511=Dual channel established successfully
513=Expression returned: %s
517=Sign in
520=Fog calculation syntax expression
521=Automatic disconnection prevention
522=Get remote file information (ZDB package)
524=Zserver4d is a server middleware
525=Tunnel principle:
526=Vmtunnel is our tunnel server. We trigger the request by intercepting the built-in tunnel of the server. In the request, we can dynamically bind our recv + send channels
527=If the bound channel is a server type, one to many to many can be the same server, and can be bound to multiple VM tunnels to realize VM virtual tunnel service. VM virtual tunnel service has no limit on the number of links, and a virtual tunnel can carry more than 1 million links
528=Once the tunnel is established successfully, vmtunnel can also send and receive commands normally. The tunnel binding of recvtunnel + sendtunnel will not affect vmtunn
530=Once the tunnel is established successfully, the vmtunnel protocol will change. It is not a special case. Do not cancel the tunnel easily
531=All virtual tunnels have been connected
533=It took %d milliseconds to execute the expression 1 million times
534= 88:: equivalent to 88:0:0:0:0: 0 is the virtual IPv6 in p2pvm, not the real physical address. This address needs to be matched with the p2pvm service listening address 
535= The demo client of the HPC can be opened more, and the better the server CPU, the better the computing power 
536= Sending feedback in blocking mode 
537= Send feedback asynchronously 
538= Loop call 
542=Click build 10000 connect and wait a moment. If the machine configuration is not high, the client will get stuck more frequently
543=1. In the middle, please open the resource monitor and locate it in the client process
544=2. Pay attention to the system resource overhead
545=3. In the middle of the pressure test, the client will get stuck with link failure
546=4. The server will not get stuck
547=5. After the link is completed, the test command button will be displayed
548=6. Click test command, and the test over command will be printed together with the client ID
549=7. It takes time for the server to feed back the print command
550=The client uses the link pool to link. Each time the client links, it will shake hands with the server. Encryption and hash protocol are blocked on the client. The limit on the client is 100 concurrent per second, and the server is not subject to the concurrency limit
557= One level nesting based on anonymous functions 
558= Two level nesting based on anonymous function 
559= Three level nesting based on anonymous function 
564= Evaluator, support vector expression: 1 + 1,2 + 2,3 + 3 
565= The underlying symbol parsing API does not support vector expressions: 1 + 1,2 + 2,3 + 3 
575=User %s logged in successfully
576=User %s is offline
577= Do not authenticate, accept all user login 
587= Simulator test client 
588= We can open two apps for simulation testing, which is convenient for direct built-in implementation 
589= Reverse proxy port 8000 of the public network server to become the local server 
590= After the intranet penetration server is started, the local server will automatically start service, and the local server will not listen on any port 
591= Simulation test: connect to public network server 
592= This is a built-in client accessing the built-in server. The client has a blocking mechanism. Pay attention to the dead loop 
593= The method of avoiding dead loop directly uses asynchronous mode 
595=Zserver4d pressure test server
596=Test method:
597=1. Start the service
598=2. Open the client and click build connect. Do not close the client until the processing is finished
599=During the link, it is slow to create the link because it needs to shake hands to negotiate encryption and hash protocol. After the link is created successfully, the client can send a command to test, and the response speed is very fast. When the client exits, the server has no memory leakage
601=P2P VM openbefore requester IP: %s
602=P2P VM open requester IP: %s
603=P2P VM openafter requester IP: %s
604=P2P VM close requester IP: %s
605=P2P VM server online: %d
606= P2P VM is a virtual machine based on Io. It has no requirements for server and client models,
In short,
The P2P VM server and client can work on the physical client as well as the physical server
As long as IO exists, P2P VM can work
If we build a background server based on P2P VM, the expansion space will be very flexible and not limited to any network environment 
607= The demo will first create a physical client, and then run a P2P VM server based on the physical client 
608= P2pvm handshake step 1: Remote Authentication 
609= Automatic reconnection 
610= After p2pvm is installed by the installlogicframework, progress will automatically call myp2pvm_ Server.Progress 
611= Green environmental protection, energy saving for CPU 
612=Complete physical Tunnel Link
614=User1 dual channel construction completed
616=User2 dual channel construction completed
618=User3 dual channel construction completed
619=User %s dual channel established
620=Noauth1 dual channel established
621=Noauth2 dual channel established
622=Physical link established
631=The technical mechanism mainly focuses on the large-scale operation on the server side. When the server receives a streamcmd command, the traditional processing method is that the server is blocked in the command, and other requests are waiting. We don't let the server block at this moment. We use the delay technology to tell the background to pause the feedback (pauseresultsend)
632=Then, we start a background thread and let the background continue to feed back (continueresultsend) after the thread execution is completed
633=In the HPC background demonstration program, the above process is automated. It is very simple to use. Using this mode, you can accumulate code indefinitely
635=Zsserver4d is a server middleware. This demo is a login two-way mode
636=Login explanation: authentication must be performed when initiating a connection, because there is user identity in the login. In the logged in server system, each user has its own file storage and data storage space
637=Compared with the simple two-way working mode, the login two-way communication mode adds the following functions: asynchronous login (client) large file transfer support (server, client) stack instruction storage (server) storage space and data management (server) preemptive login (server)
644=Listening to physical IP %s: %d succeeded!
645=VM client
646=Heartbeat 
647=Create VM network
648=Physical address
649=VM address (IPv6)
651=Link VM address
652=Elegant test VM performance
653=Disconnect VM address
654=state
655=Over testing VM performance (x64)
656=P2P VM client status completed connection: %d half open connection: %d
657= The demo will first create a physical server, and then actively initiate the p2pvm handshake after the client is connected. After the handshake is successful, 20000 p2pvm client connections will be made 
658= This event indicates when the physical client link is completed 
659= We use the delay engine, throw a 2-second post event, and then start shaking hands 
662=Cli1 dual channel construction is completed
663=Cli2 dual channel construction is completed
664=Cli3 dual channel construction is completed
667=There are 4 memory hook copies in ZS project, which can span all platforms and have excellent performance. The principle is to control the memory overhead of our program by hooking the memory management unit and recording the allocated address
668=Scenario 1: when we create a class, we hook it and monitor the memory overhead of the class
669=Scenario 2: we can hook a function in the server. When the function exits, we can calculate the allocated space of the function. Finally, we can judge whether there is a leak in the function
670=Scenario 3: a large number of memory hooks are used in zdbengine to manage cache memory overhead
671=Mh.pas memory hook for batch management
672=MH_ 1. PAS hooked for the first time
673=MH_ 2. PAS second hook
674=MH_ 3. PAS third hook
675=The following is dostatus information
676=Function call monitoring
677=Calculate the real memory size of the record and release it
678=High performance hook optimization for high frequency memory statistics
679=Record mass memory requests
680=Strict memory monitoring
697=Command execution time:
698=Command received:
699= One way server framework 
700= Precise physical beat time engine to support delay processing engine 
701= The delay event processing engine is used to simulate the asynchronous delay of the server 
702= Find the ID from the client linked list. If the client does not exist, return the nil value 
703= During the delay, the client may have been disconnected 
704= Immediately feed back the response data to the client and continue to process the internal waiting queue status 
705= After the delayresponse command is executed, it will not give feedback to the client immediately 
706= The delayed response mechanism is implemented by state machine. Once the response stops, the instructions in the queue will be in the waiting state 
707= The delay mechanism is mainly used for cross server communication or nonlinear processes 
708= Throw a one-time event to be executed after 3.5 seconds to the delayed event engine 
709= This event is used to asynchronously simulate the communication delay with another server on the server 
710= Suppose another server responds to the data after 3.5 seconds. At this time, it processes the command asynchronously, and then continues to feed back to the client 
711= During the delay, the instructions in the queue will be waiting 
712= Delay needs to record the unique ID of the current client 
713= Based on the official crosssocket document, if the binding string is empty, bind IPv6 + IPv4 
714= Throw a one-time event to be executed after 1.5 seconds to the delayed event engine 
715= Suppose another server responds to the data after 1.5 seconds. At this time, it processes the command asynchronously and then continues to feed back to the client 
717='marker table '
719=Marker table
743= ZDB has its own high-speed JSON mechanism, which will generate JSON instance cache during traversal, so as to avoid repeated load and accelerate query traversal 
744= In the demonstration, we use stream, load every time we traverse, and then judge the conditions, which is more in line with the principle of ZDB 
745= Bigstreammemoryswapspace: when the data sent by bigstream is tmemorystream or tmemorystream64, file transfer will be started to free memory 
746= This option is mainly used to deal with the sudden outbreak of data entry download requests: thousands of bigstream transmission tasks 
747= Bigstreamswapspacetriggersize, which is the trigger parameter of file transfer condition. Tmemorystream must occupy 1024 * 1024 memory space to start file transfer 
751= Penetration protocol compression options
Recommended usage scenarios:
If the agent's data has been compressed or encrypted using HTTPS, the compression will be invalid, and even the compressed data will be larger
If the time raw data protocol, such as FTP, HTTP without s, TenneT, the compression switch can be turned on and the speed can be increased slightly 
752= Reverse proxy the 18888 port of the public network server to become a local server. There is only one physical connection 
753= server.OfflineTimeout := 3 * 60 * 1000;        //  Offline reconnection technology, disconnect the instance of stableio 3 minutes after offline 
754= server.PhysicsServer.TimeOutIDLE := 60 * 1000; //  The physical client is offline if it does not respond for 60 seconds 
755=VM built in server
756=Listen on VM service port
757=Pause VM listening
758=Elegant close
759=Elegant instruction test
771= By default, tmyservice will not save user information to userdb, and many useless directories will be generated every time you exit the server 
772= When we open allowsaveuserinfo, all user information will be permanently recorded 
773= Note: in the future, when we want to maintain the user database, we can only do it through programming. Directly managing files is anti-human 
774= When the dual channel server with authentication is started, the user database must be read manually. This step will use a lot of swap memory. If the size of userdb is 300m, 2G memory overhead is required for reading 
775= After the user logs in, in order to speed up the retrieval of user data, all user information is stored in memory. If the size of userdb is 300m, the running memory overhead is about 1g 
776= If there are too many users, such as more than 100000, the memory of X86 platform is not enough. You need x64 
777= Loaduserdb uses a high-speed hash table internally for search. It reads very fast but consumes memory 
778= Based on the official ICs document, the bound host interface cannot be empty. You need to specify IPv4 or IPv6 
780= Delete business card photos 
781= Delete business card 
788= Check whether the dual channels have been successfully linked, and ensure that the initialization of symmetric encryption and so on has been completed 
789= Merge two channels asynchronously 
790= Dual channel link succeeded 
791= Merge two channels synchronously 
794= //Dual channel link succeeded 
796= Register communication instructions that can be initiated by the server 
797= Send in blocking mode and receive stream instruction 
806= Stable IO principle
Stable IO intercepts the transceiver events of physical IO (IO of any synapse, corss, diocp, Indy and ICO), and is independent of a stable IO called stable io
Stable IO is virtualized. It will not be like physical io. After disconnection, the instance and site are destroyed. Stable IO is still working after disconnection. Stable IO is in an offline working mode.
When the physical IO is reconnected, the stable IO will leave the offline mode, enter the online mode, and restore the site
The server for stableio must be the Tcommunication framework_ StableServer
The client of stableio must be the Tcommunication framework_ StableClient
The two must be numbered before automatic disconnection reconnection and field capacity recovery can be carried out
Ordinary clients can also directly use the stable IO server, but they do not have the function of disconnection and reconnection
Running the demo of stableio makes it easier to test and verify using the physical network system 
807= Important parameters 
808= We use xnat as the physical server for stable IO, because the author is lazy and doesn't want to define different communication interfaces used by various platforms 
809= When the client connects with the server, it will automatically enter the working mode of sequence package 
810= The sequence package will use 2-3 times the memory under normal conditions 
811= The function of limitsequencepacketmemoryusage is to limit the memory usage of sequence package working mode 
812= 0 means unlimited use of memory, 1024 means limited to 1KB of memory 
813= If you want to give a limit, it is recommended to give 64 * 1024 * 1024 on the server side, which means to limit the maximum memory overhead of 64M sequence table. If the client can not limit it directly 
814= When the limit is exceeded, the virtualized IO connection will be forcibly closed and memory will be reclaimed 
815= Under normal circumstances, only two scenarios will use a lot of sequence package memory 
816= 1밐 In offline mode, because the data sent cannot reach the target, it will accumulate in memory until it exceeds the memory security limit or reaches the offline time limit 
817= 2밐 In high-speed networks, such as local to local or Gigabit, when sending and receiving large completebuffer and bigstream, the sequence packet communication mode will use 2-3 times the normal memory overhead 
818= Using the stable IO mechanism, it is recommended to use a 64 bit operating system, windows or Linux, and ensure that sufficient memory is configured 
819= When the client is offline, the stableio will start the offline working mode, and all data sent to the offline will be temporarily stored in memory 
820= This parameter is how long the client is allowed to go offline, in milliseconds 
821= If it is high-frequency network data sending and receiving, the accumulation time is too long, which will crash the memory 
822= We use the 5-minute offline limit here. Within 5 minutes after unplugging the network cable, reconnection can be restored to the scene 
823= be of no great importance 
824= When Myserver is released, the physical server txphysicsserver is automatically released 
825= During the Myserver main loop processing, the physical server txphysicsserver is also processed 
826= Iobusy is an IO status checking mechanism applicable to any platform. When IO has data to process, it will return true 
831=No feedback received, abnormal disconnection
832= Due to asynchronous operation, the client is often difficult to write in the normal process. Therefore, we often need to use the switching structure 
833= Pmydefine is a switching structure, which maintains the data consistency of asynchronous programs 
834= This event is triggered if the client is not offline and receives feedback from the server 
835= When this event is triggered, the call of delayresponse2btnclick has ended. At this time, we cannot directly access the P variable because the stack has been destroyed. We need to retrieve the pointer data of pmydefine to P2 
836= If the other party is offline, this event will not be triggered, and the pmydefine memory we just applied for will also be lost 
837= While waiting for feedback, the line is disconnected. This event is triggered 
838= Since the event of successfully receiving feedback will not be triggered, pmydefine needs to be released here 
839= When the event here is triggered, in fact, the delayresponsebtnclick has been executed, and the variable a no longer exists. At least it is out of the scope of the normal program 
840= When an asynchronous event is triggered, a is in an unbroken stack space, which is out of normal use because it is an asynchronous event 
841= Do not refer to external local variables in asynchronous events. Try to use global variables or asynchronous events in para mode. Specify and pass variables in pointer mode. Refer to the implementation of delayresponse2btnclick 
842= Do you know whether the reference of variable a is a copy or a pointer? 
843= The answer is pointer. Delphi's anonymous function will automatically reference the external variable into a pointer. When you reference, you are accessing something in an unknown area 
844= A printed here is 456 
845=Principle of tunnel client:
846=Firstly, it is established through vmtunnel. In the anonymous function event, the handshake success status of vmtunnel virtual tunnel is obtained. When the tunnel handshake is successful, the subsequent operations are consistent with the verified dual channel
865= After practical testing: Indy can't lock threads with the system atomic lock under Linux. We can solve the problem by simulating the atomic lock and memory barrier in the critical area
After practical testing: the high concurrency problem of crosssocket under Linux has been repaired. I have found the technical details and mechanism problems in the communication framework_ Server_ Crosssocket.pas
Ezlinuxserv project is written in Delphi xe10.1.2
Please replace Delphi xe10.2.2 or above. If we can't find Linux in the platform drop-down item, create a new console project and copy the code 
866= Main cycle 
867= Change the maximum completebuffer. It is only used for testing. The server runs normally. It is generally 4m here 
868= Register the completebuffer directive 
869= Enter the main cycle 
870= Delay synchronization check 
872= Send a hello world command in the form of console to the server 
873= Send a hello world instruction in the form of stream to the server 
877=Parallel add demonstrates four ways to manipulate integer atomic variables
878=Parallel lock demonstrates two kinds of security state machines, string
880=Parallel 19937 demonstrates the unity of 19937 random numbers in parallel and multithreaded programs
882=Parallel trondom demonstrates the unity of trondom in parallel and multithreaded programs, and its performance is better than using 19937 functions directly
884=Delphi trondom demonstrates how to replace the built-in random in Delphi, so that it has the unity of parallel and multithreaded programs and realizes large-scale algorithm transplantation. This method only supports xe10.3 or later versions, but xe10.2 is not supported. See the code remarks for details
886=Tcompute is a thread instance of large-scale computing, which automatically manages thread pool, computing queue, granularity parallelism and so on
887=The threads in the tcompute thread pool will only be idle for 1 second. When our thread reaches 1 second, the thread will be released
888=Tcompute thread pool can be nested layer by layer, such as thread set parallelism and then set parallelism inside
889=Tcompute and parallel programs share thread pools and thread instances
890=There are many tcompute state machines, most of which are internal state machines, which are obtained through the state machine functions provided by tcompute
891=Tcompute provides local near procedure for FPC and anonymous procedure for Delphi
929=Stable IO principle
930=Stableio intercepts the transceiver events of physical IO (IO of any synapse, corss, diocp, Indy, ICO) and creates an independent io
931=Stable IO is called stable io
932=Stable IO is virtualized. It will not be like physical io. After disconnection, the instance and site are destroyed. Stable IO is still working after disconnection, S
933=Tableio is in an offline mode.
934=When the physical IO is reconnected, the stable IO will leave the offline mode, enter the online mode, and restore the site
935=The server for stableio must be the Tcommunication framework_ StableServer
936=The client of stableio must be the Tcommunication framework_ StableClient
937=The two must be numbered before automatic disconnection reconnection and field capacity recovery can be carried out
938=Ordinary clients can also directly use the stable IO server, but they do not have the function of disconnection and reconnection
939=Running the demo of stableio makes it easier to test and verify using the physical network system
948= For server pressure test, the following interfaces can be selected 
949= Only crosssocket and diocp can resist concurrency. Other interfaces such as Indy and ICs can only be used for small-scale services within 500 links 
951=Create 128M temporary big data stream
952=Calculate temporary big data flow MD5
954= Send and receive stream instructions asynchronously, and the feedback is triggered by method callback 
955= The MS contains 128M large data, which is equivalent to executing a common command on the server 
956= Send an instruction in the form of big stream to the server 
957= Sendde contains 512k large data, which is equivalent to 512 ordinary commands on the server side 
958= Send an instruction in the form of direct stream to the server 
959=Business file: %s size: %s
960=Ad board file: %s size: %s
961=Remote fog server is calculating
967= We use xnat as the physical client for stable io. We are lazy and don't want to define different communication interfaces used by various platforms 
968= When myclient connects for the first time, it fails and will try again all the time. This is done asynchronously and automatically in the background 
969= When myclient is released, the physical server txphysicsclient is automatically released 
970= During the myclient main loop processing, the physical server txphysicsclient is also processed 
971= Method 1, blocking link 
972= Method 2, asynchronous dual channel link 
979=The public network server of xnat is used for the public network protocol interface
980=The mobile server of xnat is a server model that works on mobile phones or IOT devices
981=In the public network protocol interface, xnat uses P2P VM technology to demonstrate how to make mobile phones carry a large number of physically connected services
982=The maximum physical concurrent connection limit for xnat is 4000
983=The demo uses the following techniques
984=P2P VM: protocol stack virtual machine technology
985=Stable IO: anti break Technology
986=The demo can open more xnatmobile servers. After that, it will be a distributed load
987=It can enable WiFi or 4G of Android / apple / IOT devices to carry a large number of physical connections, and is not afraid of disconnection
993=Serialized command queue demo
997=Stream can be sent and received in the following 5 ways:
1003=Link successful
1004=link failure
1005=Create 16m temporary big data stream
1007= Method 2, asynchronous high-speed link 
1008= The MS contains 16m large data, which is equivalent to executing a common command on the server 
1019=Register new users
1020=Sign in
1022= User ID, user password 
1029= High speed synchronization without progress trigger 
1030= This is done to minimize the delay rate of time 
1031= Because after synconresult is opened, nested deadlocks will occur in anonymous functions 
1032= We now turn it off to ensure nested execution of anonymous functions 
1033= Nested anonymous function support 
1036= Tpeerclientuserspecial is an instance that is automatically created on a per user basis 
1037= Please pay attention to freeing memory when using 
1038= Tpeerclientuserdefine is used for auth, DB and other services 
1039= Tpeerclientuserspecial is used to provide exclusive instances for developers in case of conflict with auth and DB of advanced services 
1048= Query hall server 
1069=chinese
1071=Tmyrec allocated %d times of memory and occupied %d bytes of space,
1072=Leaked address: 0x %s
1073=Successfully freed address: 0x %s occupied %d bytes of memory
1080= We'll find a leak here 
1081= Now we can release the address directly 
1086= Send an instruction in the form of completebuffer to the server 
1087= The last Boolean parameter indicates whether to release buff after sending 
1089= Dostatus ('link succeeded ') 
1091= Dostatus ('link failed '); 
1100= Modified: love to eat pig head meat & flying Wang 2015-04-24 
1101= Please do not remove the above copyright notice. 
1102= It is forbidden to publish to citcom network disk. 
1106= StrToHex aka BytesToHex목Bytes2Hex목Str2Hex 
1109= HexToStr aka HexToBytes목Hex2Bytes목Hex2Str 
1116=The leakproc function allocated %d bytes of memory
1126=Total memory allocation %d times, occupying %s space, address span: %s
1128= 1 million times of repeated hooking and repeated release 
1129= This scenario can be used to count your program overhead and record memory consumption 
1130= Now we can release the address 
1131= 2 million mass recording memory applications, and finally released at one time 
1132= This scenario can be used to release leaked memory in batches 
1133= We built 200000 hash arrays for storage 
1134= The larger the parameter of beginmemoryhook, the better the performance of high-frequency recording for mass storage, but also the more memory consumption 
1135= Simulate string assignment and trigger realloc call at high frequency 
1136= Here is the iteration call. We don't record the MH_ 3. Set memoryhooked to false 
1137= Continue recording memory requests 
1138= Because there is no reference before and after, realloc and GetMem here will not be recorded 
1139= Because the s string has been initialized at the beginning of the call and there is no previous and subsequent reference, the realloc here will not be recorded 
1140= The GetMem address of sptr will be recorded here 
1141= When realloc to sptr occurs, MH will look for the previous and subsequent text. If the realloc recording conditions are met, MH will record it and release it later 
1142= MH supports control creation and release 
1143= MH does not support the release of the tform window, because the tform window will register global parameters. After MH releases the tform, some callbacks will report an error if there is no address 
1148= HPC delay background operation mechanism demonstration, the mechanism is very simple, and can stack engineering code on a large scale 
1149= If there is a dispatch center server in your background server framework: managerserver 
1150= We need to tell the dispatch center server in the running area of the main process that I have started large-scale computing 
1151= The difference between HPC delay background operation and traditional processing is that we need to use thindata and thoutdata to identify and feed back data 
1152= Dostatus can be used in HPC background calculation 
1153= The code here works in the thread zone 
1154= If you need to synchronize to the main thread, you need to use 
1155= This is the synchronization zone of the main process, such as file operation, ZDB database operation, etc 
1156= Parallelization is safe in the background deferred threads of HPC 
1157= Parallelfor is better than Delphi's built-in tparallel.for 
1158= Parallelfor is better than mtprocs built into FPC 
1159= In parallel processing, we cannot use the TThread. Synchronize method because of the design problem of EMB 
1160= In parallel processing, we can use zserver kernel atomic locks 
1161= We need to tell the dispatch center server in the running area of the main process that my large-scale computing work is finished 
1162= Finally, at the end of the deferred run, thoutdata will be sent to the client, and then the temporary memory will be released 
1163=Chinese test
1164=Hello world
1166= JSON transceiver 
1167= Sendde contains 4m large data, which is equivalent to 512 ordinary commands on the server side 
1168=User %s successfully established interactive link
1173=An average of %d addition, deletion and modification operations are received per second
1174=Active database
1175=Library %s entry: %d size: %s cache %s
1176=Working query pipeline
1177=Pipeline %s crawls %d times per second
1178= Query is the trigger frequency of high throughput. Calling events will generate millions of times per second 
1179= When writing query, you must pay attention to optimizing the program and compare the conditions with the least code 
1180= Try to avoid creating entity objects in query. Creating objects with high frequency is too slow to query efficiency 
1181= Get a JSON object from the database 
1182= Sacrifice performance for safety inspection 
1183= The values in dpipe come from the query parameters sent by the client, not the database 
1186=Zserver custom client connection succeeded
1188= Tpeerclientuserspecial is a special instance interface after P2P link of each client 
1189= We can also achieve the same function by inheriting tpeerclientuserdefine 
1190= Here is the synchronization event, where we implement the fragmentation buffer processing process for overlay writes 
1191= Get external customized processing buffer interface from server 
1192= The buffers here are all fragmented buffers 
1193= Custom protocol server 
1194= Custom protocol client 
1195= First check whether the buffer is empty 
1196= If the buffer is not empty 
1197= We print the received data content 
1198= We feed back the received data to the sender intact 
1199= Clear the buffer to prepare for the next processing 
1200= Filldone's role 
1201= If filldone is true, the kernel will think that you have processed the buffer. After exiting the event, it will not process it again 
1202= If filldone is false, the kernel will handle it according to the normal mechanism of ZS after exiting the event, including dragging the secret key and decompressing it 
1203= Filldone is true when protocol: = cpcustom. If protocol: = cpzserver, this event will not be triggered 
1204= We append the fragment buffer to mybuffer 
1205= Use custom communication protocol 
1206= Specify the P2P instance interface of the client 
1207= Check feedback from the server 
1208= When we receive feedback, we print the feedback from the server 
1209= We use the Indy interface to send a uint variable to the server 
1210= Note here: if the conversion parameter is turned on, the large end byte order conversion used by Indy (the early Indy version is designed to be compatible with non Intel Architecture), so we need to turn off the conversion 
1225= Login history information 
1226= User messages and messages 
1227= Log database 
1228= Fog calculation history database 
1229=Win64 compilation
1230=Win32 compilation
1231=File size: %SMB load time: %d milliseconds
1232=Indy MD5 time consuming:
1233=MS MD5:
1234=Fly MD5 time consuming:
1235=Fast MD5 time consuming:
1236=Qdac MD5 time consuming:
1237=System MD5 time consuming:
1238=Mormot MD5 time consuming:
1257=VM built-in server... Active client %d half open link %D linked %d
1262= User not logged in successfully 
1263= Channels not merged 
1264= The broadcast method does not distinguish whether the client has logged in or whether the dual channel has been successfully established 
1265= If the client does not log in successfully 
1266= As above, if the client is not logged in 
1278= The server can write instances directly, but the client should better encapsulate them and form a habit, otherwise the maintenance will be troublesome after the project pile is large 
1279=VM tunnel linked
1280=VM is shaking hands
1281=VM shook hands
1283=VM client (%d)... Half open link (%d) link complete (%d)
1284=Heartbeat packet: %s
1286=Dataset service
1287=ZDB dataset service: take Jason as the data structure to demonstrate that the ZDB interface used by the actual ZDB to the dataset service in the project is an authentication interface. The client needs to log in. The default login account has two users: test1 password: test1
1288=User: test2 password: test2
1289=ZDB is a very violent large database processing engine, which is now being used in a large and medium-sized project. In the near future, ZDB will combine clustering algorithm to solve the problem of in-depth data processing. Using ZDB as an application for small and medium-sized enterprises is killing chickens with ox knives. If you want to apply it to the field of small and medium-sized enterprises, please rest assured to use ZDB
1290=For the security of important data, please use the corecipher library to encrypt and decrypt by yourself (remember to turn on the parallel encoding switch of zdefine.inc)
1291=ZDB queries are fed back in the form of fragments, which can be sent from 1000 lines. Fragments can still have correct feedback results
1292=ZDB database can work in two media: disk file and operating system memory. Because it does not support virtual memory, when using ZDB, pay attention to controlling cache parameters according to its own background configuration
1293=ZDB temporary database will use memory copy. For commercial use, please prepare one of fastmm, tcmalloc, jemalloc and nexusdb professional database
1294=A memory support library, and please read the technical paper in a certain memory optimization field
1295=Running ZDB does not require array support. ZDB only requires medium-sized memory (for example, running tens of millions of entries for query + analysis, using 128G memory + 2-core CPU). Note: after ZDB database entries exceed tens of millions, the memory throughput in parallel lines is very large. If the memory is not enough, please reduce the cache limit parameter, In exchange for stability at the expense of performance note: do not run ZDB server on X86 platform note: for Windows server running ZDB, please select server2012 and above systems, and open the parallel option at zdefine.inc. note: the server running ZDB needs to perform compress operation at least once a week to improve disk life and query efficiency. Note the above four points, ZDB is a very violent large data engine
1296=The operation method of ZDB client is consistent with that of single machine
1297=ZDB network clients work in zero blocking asynchronous mode
1298=The demo provides basic addition, modification, deletion, query and other demonstration methods
1299=There are 2 sets of ZDB network services, 1. With authentication and 2. Without authentication. The demo uses the ZDB server model without authentication
1300=The characteristics of ZDB network service are very clear. The query can be operated manually, and there is no need to submit and modify the stream at high speed with SQL statements
1301=Support big data cutting, big data analysis and professional HPC
1302=The single IO concurrency mechanism supports the annealing cache in the middle and low end cloud background: the more parallel queries, the faster. After the query task is completed, ZDB will automatically anneal, which can force the limit of big data throughput
1303=ZDB's network services are carried out in the background. Zero blocking is often done in the background. ZDB compression is safe. There is no memory leakage in the network and background databases. There is no need to install controls and set a directory to compile ZDB
1304=ZDB is not only competent for rough and heavy data processing, but also can be used for the companion data system attached to the main database system. The database data transmission is encrypted, and the data storage is not encrypted (please solve the storage encryption manually). The disk pre reading and write back support is provided at the bottom of the database. Using ZDB does not need to consider the problem of synchronous and asynchronous concurrency, but only needs to write data matching judgment and data processing
1305=There is almost transparent information about the internal working state of ZDB on the right side of the server and client. If it is not enough, vmmap, deskmonitor and other tools can be used to observe the memory
1306=Due to the time relationship with the IO status of the hard disk, the demo will not do much. For example, for the operation method based on JSON, please refer to tdataframeengine (do not save JSON to t)
1307=In the dataframeengine, ZDB can be operated directly (Jason). The author's maintenance time for ZDB is fragmented. If you find any problems, please try to contact me by email, QQ email 600585 qq.com
1326= Demonstrate the receiving and sending of stream 
1327=ZDB dataset service: take Jason as the data structure to demonstrate that the ZDB interface used by the actual ZDB to the dataset service in the project is an authentication interface. The client needs to log in. The default login account user: test1 password: test1. The login interface is a virtual interface. Any user can log in
1328=Remote authentication of login virtual interface user cloud background
1335= The postassemblystream method will submit data to the server using the batchstream mechanism 
1336= The postassemblystream method compresses and encrypts the data before submitting it 
1338= The fastpostcompletebuffer method will submit data to the server using the completebuffer mechanism 
1339= The postassemblystream method will not do any operation on the data before submitting it. If important data is transmitted on the public network, confidential data may be leaked 
1342= VM tunnel 
1343= The VM tunnel can take up the work of the whole protocol stack while working normally 
1344= Here, we will bind recvtunnel + sendtunnel in vmtunnel at the same time, and use only one link to implement dual channel service 
1345= VM tunnel can be any socket, bedstead, Indy, ICs, crosssocket, etc. all support VM tunnel 
1346= ZS normal communication framework 
1347= If VM tunnel handshake succeeds 
1348= Bind the client framework to the tunnel 
1349= There are two clients here. We bind them 
1350= Asynchronous dual channel link 
1353=Thread [%D] random number sequence: %s
1354=The installmt19937coretodelphi compilation option is not turned on
1355=Please edit the file zdefine.inc
1356=Open the compilation option: installmt19937coretodelphi
1357=Open compilation option: mt19937seedontcomputethreadis0
1358=Thread start
1359=Analog delay %d MS
1360=Done
1361=All threads have ended
1362= The structure named tatomxxx supports multithreading and parallel programs. The difference from ordinary variables is that it needs to be initialized before use and released when not in use 
1363= Workinparallelcore can only be opened in non ide environment. It is closed in debug mode. We force it to open 
1364= Operation method 1: take value after locking, perform Inc operation once, and then unlock 
1365= 1 and 2 the two operation methods can be used compatible 
1366= Operation method 2: take value after locking, perform Inc operation once, and then unlock 
1367= Similarly, we can also write 
1368= Common sense program errors to avoid 
1369= The workflow of the following code is as follows 
1370= 1. Lock and then unlock 
1371= 2, value + 1 
1372= 3. Unlock after locking 
1374= The operation method of the atomic API is incompatible with the lock method and cannot be operated at the same time 
1375= Operation method 3: directly operate the pointer value through the atomic API, which can only support integer operation 
1376= Operation method 4: directly operate the pointer value through the atomic API, which can only support integer operation 
1377= Unlock after locking 
1378= Lock, value, if the value is' 55 ', process and unlock 
1379= Unlock after locking. If the value is' 99 ' 
1380= Generate one random number at a time 
1381= Each time mt19937rand32 is called, it will find the mt19937 instance bound by the thread, where the thread will get stuck briefly 
1382= High frequency calls should use the TRANDOM class instead of mt19937rand32 
1383= Random numbers are generated through the trondom class. Random numbers generated through the trondom class will not cause a jam on the thread. It is suitable for concurrent programs pursuing extreme performance 
1384= The random number of thread unity is generated through the random function of Delphi. It must be initialized before using this function 
1385= Generate thread uniform random number through Delphi's own random function 
1386= We open 10 tcompute threads 
1387= Mythreadnum is our custom thread counter. When creating a thread, let it + 1 
1388= RunP_ NP = run procedure no parameter abbreviation. This method provides an anonymous thread without parameters 
1389= Tcompute.sync is a relatively faster synchronization method, which is equivalent to tthread.synchronize 
1390= Disrupt random number seeds 
1391= Dostatusnoln = dostatus no line, no line feed is printed, the parameter is to print and clear the current line, which is thread safe 
1392= Random delay 1-5 seconds 
1393= Dostatus is a status printing support method, which is thread safe 
1394= Mythreadnum is our custom thread counter. Let it - 1 when the thread ends 
1395= The simple implementation waits for the calculation of these 10 tcompute threads to end 
1396= If tcomputed in the child thread, write directly as TThread. Sleep (10) 
1397= If tcomputed in the main thread, the following method can be used 
1421=The demo uses ZDB as the data entity to simulate the transmission operation of dataset
1422=Working idea of remote SQL for dataset:
1423=On the client side, we first create a record. This container is used to store our query results
1424=Then, we send a query command "querymydatabase" to the server and take record as a parameter
1425=Next, the server uses query or its own defined data processing technology to process your query criteria
1426=After the server completes the query and processing of data, the server will feed back according to the combined command of batchstream
1427=Batchstream combined command mode, which is about these four steps
1428=1. Clearbatchstream / / reset the remote batchstream container
1429=2. Postbatchstream / / start transmitting our query results
1430=3. Sendqueryresult / / tells the client that the query result has been transmitted
1431=4. Clearbatchstream / / reset the remote batchstream container
1432=These four steps of sending work are done on the server
1433=The reception and processing of these four steps are done at the client
1434=In this demo, the query and advanced database engine of Delphi are not directly used
1435=In this demo, ZDB is used to simulate query and advanced database query engine. Its working mechanism and implementation idea are the same as that of database engine
1444= The demo uses ZDB as the data entity to simulate the transmission operation of dataset
Working idea of remote SQL for dataset:
On the client side, we first create a record. This container is used to store our query results
Then, we send a query command "querymydatabase" to the server and take record as a parameter
Next, the server uses query or its own defined data processing technology to process your query criteria
After the server completes the query and processing of data, the server will feed back according to the combined command of batchstream
Batchstream combined command mode, which is about these four steps
1. Clearbatchstream / / reset the remote batchstream container
2. Postbatchstream / / start transmitting our query results
3. Sendqueryresult / / tells the client that the query result has been transmitted
4. Clearbatchstream / / reset the remote batchstream container
These four steps of sending work are done on the server
The reception and processing of these four steps are done at the client
In this demo, the query and advanced database engine of Delphi are not directly used
In this demo, ZDB is used to simulate query and advanced database query engine. Its working mechanism and implementation idea are the same as that of database engine 
1445= Remote callback address 
1446= Query a local database through SQL. Of course, it can also be a remote database 
1447= Simulate SQL statements using zexpression 
1448= SQL databases use similar methods directly 
1449= Such methods generally have a syntax check before execution 
1451= When the query is complete 
1452= Both Delphi and Lazarus databases have a foundation class called dataset. Query will output query results to a dataset defined by you after executing the query 
1453= All datasets can be saved. If you don't know how to save them, search the savetostream method and you'll always find it 
1455= Because it is too troublesome to build a module to use the database, I directly use ZDB to simulate the query method of the database. My method is very violent, that is, to package the data 
1456= The query results are written to the return table 
1457= The returned table of the query is a memory table. If false, it is an entity file table 
1458= Query from last 
1459= The name of the target database for the query 
1460= Returns the name of the table. If it is left blank, a temporary table name will be randomly generated 
1461= Release the return table when the query is complete 
1462= The delay time, in seconds, to release the returned table when the query is completed 
1463= Fragment accumulation time: when there is a lot of feedback in the query, the feedback event will be triggered every time it is accumulated to facilitate batch operation. During the accumulation time, the data exists in memory 
1464= Query execution time, 0 is infinite 
1465= The maximum number of matching query entries, 0 is infinite 
1466= Maximum query result feedback, 0 means infinite 
1467= If an exception occurs in the query, end the query task immediately 
1468= You can also end the query task by the following method 
1470= This is all done after the query is completed 
1471= Release the opruntime class that is no longer used 
1472= When the query is completed, if the client has dropped the line, if the line drops, the memory will be released and no feedback will be given 
1473= When the query is completed, if the client is still online 
1474= Put the query results into mystream. Dpipe.outputdb.savetostream is equivalent to dataset.savetostream 
1475= Now, we will send mystream to the client and feed back the statistical results of the client query and the callback trigger event 
1476= Reset batchstream 
1477= Memory address of feedback callback pointer 
1478= Finally, release the queryrec we use_ PTR memory pointer 
1479= Main cycle 
1480= Simulate entity database usage 
1481= We use stable IO technology to build dual channel interactive services 
1482= Stable IO can automatically disconnect and reconnect without destroying the instance 
1483= Of course, the client also needs to be stable io 
1484= This demo is an endless loop service and will not exit, so the server will not be released. There is no memory leakage in stableio 
1485= Simulated entity database 
1486= Simulate database in memory 
1487= Create 100000 data records 
1496=ZDB local database demo provides demonstration methods for localization, basic addition, modification, deletion, query, etc
1497=ZDB is a very violent large database processing engine, which is now being used in a large and medium-sized project. In the near future, ZDB will combine clustering algorithm to solve the problem of in-depth data processing. Using ZDB as an application for small and medium-sized enterprises is killing chickens with ox knives. If you want to apply it to the field of small and medium-sized enterprises, please rest assured to use ZDB
1498=ZDB database can work in two media: disk file and operating system memory. Because it does not support virtual memory, when using ZDB, pay attention to controlling cache parameters according to its own background configuration
1499=Running ZDB does not require array support. ZDB only requires medium-sized memory (for example, running tens of millions of entries for query + analysis, using 128G memory + 2-core CPU). Note: after ZDB database entries exceed tens of millions, the memory throughput in parallel lines is very large. If the memory is not enough, please reduce the cache limit parameter, In exchange for stability at the expense of performance note: do not run ZDB server on X86 platform note: for Windows server running ZDB, please select server2012 and above systems, and open the parallel option at zdefine.inc. note: the server running ZDB needs to perform compress operation at least once a week to improve disk life and query efficiency. Note the above four points, ZDB is a very violent large data engine
1500=The characteristics of ZDB network service are very clear. The query can be operated manually, and there is no need to submit and modify the stream at high speed with SQL statements
1501=Support big data cutting, big data analysis and professional HPC
1502=The single IO concurrency mechanism supports the annealing cache in the middle and low end cloud background: the more parallel queries, the faster. After the query task is completed, ZDB will automatically anneal, which can force the limit of big data throughput
1503=ZDB's network services are carried out in the background. Zero blocking is often done in the background. ZDB compression is safe. There is no memory leakage in the network and background databases. There is no need to install controls and set a directory to compile ZDB
1504=ZDB is not only competent for rough and heavy data processing, but also can be used for the companion data system attached to the main database system. The database data transmission is encrypted, and the data storage is not encrypted (please solve the storage encryption manually). The disk pre reading and write back support is provided at the bottom of the database. Using ZDB does not need to consider the problem of synchronous and asynchronous concurrency, but only needs to write data matching judgment and data processing
1505=There is almost transparent information about the internal working state of ZDB on the right side of the server and client. If it is not enough, vmmap, deskmonitor and other tools can be used to observe the memory
1506=Due to the time relationship with the IO status of the hard disk, the demo will not do much. For example, for the operation method based on JSON, please refer to tdataframeengine (do not save JSON to t)
1507=In the dataframeengine, ZDB can be operated directly (Jason). The author's maintenance time for ZDB is fragmented. If you find any problems, please try to contact me by email, QQ email 600585 qq.com
1516= When all p2pvms are connected, bind two channels 
1517= This event is triggered after all p2pvm connections are completed 
1518= This event is triggered when the physical connection succeeds or fails 
1519= Tstreameventbridge directly forwards the data fed back by the datastore server to the client through asynchronous events 
1520= The implementation principle of tstreameventbridge is delayed feedback. See the documents and related demos for details 
1521= Query from datastoreservice using asynchronous event bridge interface 
1522= Download from datastoreservice using asynchronous event bridge interface 
1523= Data entry storage 
1524= Batch data entry storage 
1525= Query entry 
1526= Specify Item Download 
1527= Delete entry 
1528= Disconnection reconnection mechanism 
1538=ZDB is a very violent large database processing engine, which is now being used in a large and medium-sized project. In the near future, ZDB will combine clustering algorithm to solve the problem of in-depth data processing. Using ZDB as an application for small and medium-sized enterprises is killing chickens with ox knives. If you want to apply it to the field of small and medium-sized enterprises, please rest assured to use ZDB
1539=ZDB database can work in two media: disk file and operating system memory. Because it does not support virtual memory, when using ZDB, pay attention to controlling cache parameters according to its own background configuration
1540=Running ZDB does not require array support. ZDB only requires medium-sized memory (for example, running tens of millions of entries for query + analysis, using 128G memory + 2-core CPU). Note: after ZDB database entries exceed tens of millions, the memory throughput in parallel lines is very large. If the memory is not enough, please reduce the cache limit parameter, In exchange for stability at the expense of performance note: do not run ZDB server on X86 platform note: for Windows server running ZDB, please select server2012 and above systems, and open the parallel option at zdefine.inc. note: the server running ZDB needs to perform compress operation at least once a week to improve disk life and query efficiency. Note the above four points, ZDB is a very violent large data engine
1541=There are 2 sets of ZDB network services, 1. With authentication and 2. Without authentication. The demo uses the ZDB server model without authentication
1542=The characteristics of ZDB network service are very clear. The query can be operated manually, and there is no need to submit and modify the stream at high speed with SQL statements
1543=Support big data cutting, big data analysis and professional HPC
1544=The single IO concurrency mechanism supports the annealing cache in the middle and low end cloud background: the more parallel queries, the faster. After the query task is completed, ZDB will automatically anneal, which can force the limit of big data throughput
1545=ZDB's network services are carried out in the background. Zero blocking is often done in the background. ZDB compression is safe. There is no memory leakage in the network and background databases. There is no need to install controls and set a directory to compile ZDB
1546=ZDB is not only competent for rough and heavy data processing, but also can be used for the companion data system attached to the main database system. The database data transmission is encrypted, and the data storage is not encrypted (please solve the storage encryption manually). The disk pre reading and write back support is provided at the bottom of the database. Using ZDB does not need to consider the problem of synchronous and asynchronous concurrency, but only needs to write data matching judgment and data processing
1547=There is almost transparent information about the internal working state of ZDB on the right side of the server and client. If it is not enough, vmmap, deskmonitor and other tools can be used to observe the memory
1548=Due to the time relationship with the IO status of the hard disk, the demo will not do much. For example, for the operation method based on JSON, please refer to tdataframeengine (do not save JSON to t)
1549=In the dataframeengine, ZDB can be operated directly (Jason). The author's maintenance time for ZDB is fragmented. If you find any problems, please try to contact me by email, QQ email 600585 qq.com
1550=All copies are copyrighted. Zsserver4d advanced cloud server framework 2.0
1551=Version: 1.0.0 2018-1
1552=Advanced cloud server framework 2.0
1556= The default server address. If it is the local loopback address of IPv6, write 0:0:0:0:0:0:1 
1557= Scheduling server (manager server) 
1558= Business client (logic) 
1559= Fog compute client (fog compute) 
1560= Last login ID 
1561= Last logged in user alias 
1562= Last logged in remote user (can only be read and cannot be modified) 
1563= Idle lock 
1564= Cadencer engine 
1565= Idle processing threads are mainly used for global progress processing 
1566= Execution state machine 
1567= Event delivery engine 
1589=VM tunnel port 9899 listening succeeded
1590=VM tunnel port 9899 listening failed, system occupied
1594= When the VM tunnel was first created 
1595= The tunnel has successfully shaken hands 
1596= Triggered by a delay of one second after a successful tunnel handshake 
1597= The tunnel is closed. This event is triggered when a remote request or disconnection occurs 
1598= The VM tunnel can carry the work of the entire protocol stack in normal operation 
1599= When this event is triggered, the VM tunnel has been released 
1600= Restore binding 
1601= When this event is triggered, the VM tunnel has been established, but no handshake is held 
1602= If the bound channel is a server type, it can be one to many 
1603= One to many is the same server, which can be bound to multiple VM tunnels to realize VM virtual tunnel service 
1604= The VM virtual tunnel service does not limit the number of links. A virtual tunnel can carry more than 1 million links 
1605= Once the tunnel is established successfully, vmtunnel can also send and receive commands normally. The tunnel binding of recvtunnel + sendtunnel will not affect vmtunnel 
1606= Once the tunnel is established successfully, the vmtunnel protocol will change. It is not a special case. Do not cancel the tunnel easily 
1607= Bind the receive channel to the VM tunnel 
1608= Bind send channel to VM tunnel 
1609= When this event is triggered, the VM has successfully shaken hands 
1610= When this event is triggered, the VM has successfully shaken hands and 1 second has elapsed 
1611= Based on the official crosssocket documentation, if the host interface is empty, bind all IPv6 + IPv4 IP addresses 
1612= If the host interface is 0.0.0.0, bind all IPv4 addresses,:: bind all IPv6 addresses 
1613= VM only supports IPv6 address listening. VM listening does not affect the operating system and is done in the VM tunnel 
1614= The VM's tunnel service can listen to more than one at a time 
1615= We listen on Ports 1 and 2 in the VM 
1942=End of thread
1943= Generally speaking, if tcompute.postp1 is used to avoid the main thread of the card, once the threading mechanism is used, the waitsendxxx method should be avoided on the client as much as possible 
1944= Open up a state machine to detect whether asynchronous work ends. Tatom starts with thread safe variable state machines 
1945= Throw the asynchronous method in the thread to the main thread 
1946= Tthread.synchronize will get stuck in nested mode, which will not happen to tcompute.postxx 
1947= Waitp is asynchronous and other feedback, because bigstream needs time to complete, we can't do busy_ V operation 
1948= Waitp is asynchronous feedback. Because sendcompletebuffer takes time to complete, we can't do busy_ V operation 
1949= Waitp is asynchronous and other feedback, because senddirectstreamcmd takes time to complete, we can't do busy_ V operation 
1950= To schedule the main thread queue main loop, you must have this main loop to use asynchronous technology 
1951= Tcompute.progresspost main loop is a card free mechanism built with atomic lock, and its design idea is close to STL 
1952= Tthread.synchronize will not get stuck in tcompute.progresspost 
1953= Tcompute.progresspost is thread safe. It will be executed in strict order of triggering 
1954= Zserver4d itself is an asynchronous framework. In most cases, it can be operated directly on the main thread 
1955= Occasionally, we also need to use threads. Here we demonstrate that using state machine mechanism + tcompute to complete work asynchronously in threads is better than using waitsendxxx method 
1957=Dual channel link complete
1958=Complete the fragment download task
1959=Local file MD5:
1960=Connection %d Download: %d downlink traffic: %d uplink traffic: %d
1961=Remote file MD5:
1962= Multi line download is sorted out with standard data structure, and the idea is simple and clear 
1963= Taskdata is the preset download parameter of each fragment, including remote file name, fragment start location, end location, fragment MD5 verification code, state machine, etc 
1964= Generic taskdata linked list 
1965= By default, the generic linked list will not be automatically released. An automatic release process is required here 
1966= Instead of releasing the state machine, the method is compatible with the generic mechanism of FPC. The linked list of FPC does not trigger the event when it is released 
1967= Define multiple links with the concept of session 
1968= The multiple links here use p2pvm 
1969= The p2pvm construction method here is automated p2pvm with minimalist mechanism 
1970= The automated P2P VM support technology is used here. Please refer to the relevant demo for details 
1971= Logic starts with virtual connections and dual channels 
1972= Phycli is a physical connection 
1973= File stream download count 
1974= Temporary staging queue for fragment download requests 
1975= Automatedp2pvm is implemented in the create constructor 
1976= Remote file name to download 
1977= Block download size 
1978= This event is triggered when all p2pvm handshakes are completed 
1979= Establish dual channels 
1980= Avoid allowing the server to temporarily store all files in memory 
1981= The mechanism here is to request to download another fragment block after completing one fragment block 
1982= Getfilefragmentdatam is an atomic function, which realizes the data fragment download of remote files 
1983= For this part, please refer to the relevant demo of automated P2P VM 
1984= After the link is successful, the automated p2pvm will use the p2pvm handshake. This event is triggered when all p2pvm handshakes are completed 
1985= Merge fragments 
1986= 1. Get the remote file size first 
1987= 2. Build multi line download task 
1988= 3. Calculate the MD5 of the remote file to verify the correctness of the download 
1989= 4. Add to the download queue task by task 
1990=Start building large-scale CSV
1996=.CSV building.. completed %s target %s
1997=Start building large-scale ZDB
1999= %d builds completed, database size %s, kernel status %s %s
2000=Fast query simulation
2001=Loading memory
2003=Loading status %D / %d kernel status %s %s
2004=Average query time in memory mode %DMS
2005=Quick query simulation completed
2006=Background query simulation
2007=%S completed %d record queries within %s time limit
2008=Kernel status %s %s
2009=Background query simulation completed
2010=Simulation of large-scale buffer query using kernel cache
2011=Kernel buffer status %s %s
2012=All data instances have been buffered
2013=Start simulating 2 query tasks
2014=%s in %s finished querying %d records in %s time
2015=The large - scale buffer query using kernel cache has been completed
2016=Using storage address query simulation
2017=Build storage address array
2018=The storage address is being used for 100 traversal queries
2019=The query has been completed, and the average time of complete traversal is %DMS
2020=Query with storage address completed
2021=Press enter to exit
2022= Simulation build.CSV format file 
2023= CSV file size to build 
2026= Save data to physical hard disk every 10000 records imported 
2027= The tzdblocalmanager.progress method can save the database once per second 
2028= If we do not use tzdblocalmanager.progress, we can also release the cache manually: empty the cache every 200000 records imported 
2029= To traverse big data, we need to increase the hash pool of the kernel to speed up 
2030= It takes a long time to load memory query. Please wait patiently 
2031= Synchronous loading. The characteristics of this method are: during data reading, the program is unresponsive, and the loadfromstoreengine method can only work in the main thread 
2033= Loading data asynchronously is characterized by using the query mechanism. Its performance is a little worse than that of synchronous mode, but it can be asynchronous. We can let the program do other things during loading 
2034= We create a loading query task and load it in step mode, which is a pseudo asynchronous mode 
2035= Wait for the background query task loading to complete 
2036= After loading, the query will be very fast. Hundreds of millions of data are queried in seconds 
2037= Traversal query 
2038= With the help of annealing engine, multi task query will be faster than single task 
2039= Simulate 200 simultaneous query tasks 
2040= Write query results to a temporary database 
2041= The temporary database is in memory mode 
2042= Random positive and negative direction query 
2043= Target database 
2044= The name of the temporary database. If this name is empty, it is a random name 
2045= The new database of query output will be released automatically 
2046= Delay time to release temporary database 
2047= Fragment data feedback time, which is the parameter provided to the online mechanism, the ZDB of CS architecture 
2048= Limit query time, random XX XX seconds 
2049= Limit traversal records for maximum queries 
2050= Limit the return record of the maximum query 
2051= Wait for the background query task to complete 
2052= This method is to directly shut down the annealing engine and buffer all instances into the ZDB kernel 
2053= After the buffer is completed, the query speed is very fast 
2054= Start buffering task 
2055= Positive direction query 
2056= Limit query time, 0 is wireless 
2057= The getvt method is its own buffered instance 
2058= Simulate two simultaneous query tasks 
2059= Limit query time, 0 is infinite 
2061=Remote file list:
2062=File name: %s volume: %s MD5: %s
2068=Start to demonstrate the upload of breakpoint continuation in about 1 second
2075= Get remote file information asynchronously. Because all files are traversed in a for loop without going through progress (time slice main loop), this is a batch 
2076= Wait until the above asynchronous command processing is completed. Here, blocking is simulated by batch 
2077= When a batch is executed, the second batch is traversed 
2078= When the second batch traversal is completed, we print the MD5 information 
2079= Download the complete file from the remote first 
2080= Get MD5 for remote file truncation 
2081= Only the 512byte header of the file is taken and stored again to lay the foundation for the subsequent breakpoint continuation demo 
2082= Get full MD5 for remote files 
2083= Download from remote breakpoint 
2084= If the above two MD5 print results are the same, it indicates that the file download of breakpoint continuation is complete 
2085= Now let's demonstrate the upload function of breakpoint continuation 
2086= Truncate the file body to 999byte 
2087= We use private space to store uploaded files. The last parameter indicates that M64 will be released automatically after uploading 
2088= Because the sendtunnel is used to upload files, now we do a wait event in sendtunnel to detect whether the upload is completed 
2089= An event is triggered here, indicating that the upload has been completed 
2090= We began to upload the breakpoint continuation 
2091= If the above two MD5 are the same, it indicates that the upload of breakpoint continuation has been successful 
2107=Statistics of %s completed. There are %d outputs in the database %s
2108=Statistics result %s download completed, %d in total
2110=Login succeeded
2111=Dual channel link succeeded
2112=Query %s completed. A total of %d matches were found
2113= Tdbenginevl is a key value data structure prototype 
2114= The value we want to count is 1 
2115= Statistics and analysis are triggered using the mycustomanalysis filter registered on the server side 
2116= When statistics and analysis are carried out on the server side, depth matching, image similarity, text similarity, voice similarity and so on can be carried out. They will all work in the parallel platform. Of course, you also need the support of corresponding algorithm modules 
2117= Statistics and analysis can be performed statically on the server (no fragment buffer feedback, which plays an obvious role in statistics of large databases) 
2118= After the server completes the statistics and analysis quietly, we perform the step to step operation through events. ZDB is fully compatible with and supports the anonymous function mechanism 
2119= Does it feel the same as a single machine? 
2120= Mycustomanalysis is registered and implemented on the server 
2121= Whether the buffer fragments are synchronized to the client or not, because our statistics pursue the results. There is no need to synchronize here. Let the server do it. We only need to specify what to do after the statistics are completed in the completion event 
2122= Whether to write the query results to the output database. This output is equivalent to selecting to the view, but the output will copy 
2123= The output data is an in memory database. If false, the output of the query will be stored as an entity file 
2124= Whether to reverse query, starting from the last 
2125= Database name of the query 
2126= Output name of Statistics 
2127= Fragment buffer time. Because the query is too frequent, the bottom layer of ZDB will cache and compress the query results within this time, and then send them. 0 is immediate feedback 
2128= The maximum waiting query time, 0 is infinite 
2129= Maximum number of feedback entries for matching queries 
2130= KeyValue parameter sent to mycustomquery 
2131= This event is triggered when the server query is completed 
2132= After the statistics are completed, a permanent file database will be output 
2133= During the change event, we can repeatedly make statistics on the change database and query again to get the results we need 
2134= However, there is no need to make multiple queries here. The statistical results are directly downloaded to the local and displayed 
2135= After the server finds the result, here is the data feedback 
2136= The data of this event is temporary and will be killed after the call. If you want to temporarily store the query result data, you must do it here 
2137= Because the statistical results are downloaded, the server no longer needs this statistical database. Now, we will delete it 
2138= Note: if the statistics library is being accessed by a pipeline, the deletion here will make an error 
2139= To avoid this problem, we only need to ensure that the file database of statistical output is unique 
2140= The first parameter of initdb is the memory database. We set it to false to create a file database 
2141= Generate 100 JSON objects to the entity file library 
2142= Value counts from 11. Note that we use the string value here 
2143= Randomvalue is used to demonstrate statistics and analysis capabilities 
2144= Due to cross platform problems, Indy does not support disconnection events at the bottom of IOS and Android platforms 
2145= The disconnection status must be checked manually 
2146= When the connection is successful, we activate a timer to cycle to check for disconnection 
2147= Generate 10 JSON objects to the entity file library 
2148= Generate 100000 JSON objects to the entity file library 
2149= Registration and implementation of mycustomquery in server 
2150= Whether the buffer fragments are synchronized to the client 
2151= The output name of the query, because we do not write output, but also temporary memory, can be ignored here 
2178=Sum of entries that meet the conditions between 1.0 and 10.0: %F
2179=Total number of entries between 1.0 and 10.0: %d
2202= For instances created by each user, 
2203= User defined information is stored here 
2204= For example, gender, nickname, login time, number of speeches 
2205= Number of statements 
2208= In dual channel programming, linkok judgment should be added in front of the instruction 
2209= Linkok also indicates that the verification is successful, and only the users who have successfully verified are allowed to speak 
2210= Linkok indicates that you have successfully logged in, 
2211= If it is a dual channel with verification, linkok also indicates that the verification is successful 
2212= In anonymous functions, the stack is unstable. The use of data is either container variables, global variables, or replication 
2213= To avoid stack instability, we copy the data we need 
2214= The method here is to copy indata to data3, and then trigger onmsg in a post mode 
2215=Dataset client
2216=user name
2218=password
2219=The server
2220=off-line
2221=break link
2222=Generation, query, statistics
2223=Generate 10 JSON data objects
2224=Target database
2226=Generate 100000 JSON data objects
2227=Query JSON object
2228=Value supports wildcard *? The spacer is;
2230=clear database 
2231=Statistics and analysis, Jason
2232=Statistical output database
2234=Generate 100 JSON data objects
2235=Query and statistical results
2275=Before dependencies are sorted
2276=After dependency sorting
2277= This library is required for FPC compiler to support generics 
2278= The FPC compiler needs to use the specify modifier before declaring a generic type 
2279= Use Delphi's generic library and directly declare it with tgenericslist 
2280= Parse Pascal structure, support all FMX, VCL, runtime, LCL, FPC basic library + advanced library, and support parsing Delphi advanced syntax 
2281= Tpascalunit toolchain code from zexpression 
2282= Members need to be released in these three places. Notify is not used. It is a generic library compatible with FPC: the fpcgenericstructlist.pas library does not provide notify callback 
2283= Open source projects produced using this technology https://github.com/PassByYou888/FFMPEG-Header 
2284= PL can directly add code files on a large scale, and then make dependencies and automatic code base layering 
2285= We can even use this technology to make code distribution tools 
2286= Code generated using tools 
2287=Generate 1 JSON data object
2288=When you click to generate a JSON object, the following selected pictures will be submitted
2305=You must select a picture
2308= Maximum number of feedback entries for matching query, 0 is infinite 
2309= 111 is our custom picture ID 
2310= Because the query only indexes C_ The background query will jump over Jason's ID, so we can directly submit img to the same table 
2311= The function of beginassemblestream is to empty the staging buffer of the batch submitted stream to the data server 
2312= Submit the stream to the data server immediately 
2313= Obtain the database storage information of the last submitted img from the remote database 
2314= If the batch stream submitted by us has temporary data in the database, many statuses will be obtained here. We take the last batch stream status and decode it 
2315= Generate a JSON object to the entity file library 
2316= This is equivalent to our daily data 
2317= Here is the storepos we submitted img in the database this time. Here is the variable type of Int64 
2318= Endassemblystream is used to empty the staging buffer of the batch submitted stream to the data server 
2320= Downloadassemblystream this method will be maximally compressed and encrypted in the data server before downloading. This method is applicable to public network communication downloading, such as mobile terminal and PC accessing internet server 
2321= Fastdownloadassemblystream is the same as downloadassemblystream, but fastdownloadassemblystream does not process data, and its speed is faster. This method is mainly used for communication between servers 
2322= Stream is temporary and encoded data, which must be decoded using the decodezdbfragment method 
2323= After completion, it is stored in M. pay attention to releasing m at the end of the call 
2326=Index %D type: %s value %s
2329=Basic use demo
2332=String length: %d
2333=1000 + {here is the note Ze, which can recognize the notes of Pascal and C and the string writing method} myaddfunction (1 + 1 / 2 * 3 / 3.14 * 9999, 599 + 2 + 2 * 100 SHL 3)
2336=High speed loading and execution demo
2338=OP run return value (correct value is 4489.2962): %s
2339=Load and execute demo at high speed, and the operation is completed
2342=If format parsing error
2344=Then format parsing error
2346=Else writing format parsing error
2348=A simple demonstration encapsulates zexpression with a script
2350=thank you
2351=This is 1 + 1 = < begin > 1 + 1 < end >, which is a uint48 bit integer: < begin > 1 < < 48 < end >, end < begin > overfunction < end >
2352=Prototype:
2353=Calculation results
2356=Zexpression is testing its performance and processing the above prototypes 100000 times
2357=Zexpression performance test completed, time consuming: %DMS
2358=Myvar1 / * here is the remark * /, myvar2, myvar3 = 123 + 456 + "variable:" + dynamic
2360=Variable assignment syntax error %s
2361=Expressions are not supported
2364=Variable assignment expression found
2365=Variable assignment content
2366=Now, we start to statically reuse the variables we just declared. Static reuse is to compile variables in const form
2367="Static reuse" + myvar1
2368="Static reuse" + myvar4
2370=Now we begin to dynamically reuse the variables we just declared
2371="Dynamic reuse" + myvar1
2372=Variable assignment not found
2373=Expression ' %s'
2374=Run result %s
2375=Use of global lexical probe prefix parameters
2380={remarks} @@a&& (1,2)
2383= Runtime function support library with RT as Ze 
2385= Simple mathematical expression 
2386= Simple string expression. The default text processing format of Ze is Pascal 
2387= For simple string expressions, we use the text format of C. C can support single and double quotation marks, but does not support # character expressions 
2388= Use the parsetextexpressionassymbol function to translate the expression into a lexical tree 
2389= Buildasopcode will translate the lexical tree into the idiom tree again, and then generate op code based on the syntax tree 
2390= Let's do it once 
2391= The op has been released here 
2392= Quickly read OP from stream, which is convenient for us to 
2393= Simple state machine for parsing 
2394= Lexical parsing engine 
2395= Word coordinates 
2396= Parsing text state machine 
2397= Analytic structure state machine 
2398= Current parsed lexical aspect, including 
2399= Conditional Boolean judgment running body 
2400= Conditional running body 
2401= The condition does not hold 
2402= Runtime library support 
2403= Because Pascal string is not easy to write in the program, here we use C-style string 
2404= Parse main loop 
2405= If it is a code comment, skip to it 
2406= Lexical process paradigm, which focuses on mature lexical parsing without considering performance. If you need to speed up the running of scripts, please consider compiling them into data structure storage and then loading and running them in a high-speed way 
2407= The lexical process paradigm ends. Let's judge the structure 
2408= Lexical Structure  
2409= In tpascalstring, the append method is more efficient than string: = string + string 
2410= At this step, the entire if structure has been parsed successfully. We can run the program directly 
2411= If you need performance, you can consider using data structure to store the structure here to realize fast script 
2413= Here we use macro processing to translate 1 + 1 as an expression 
2414= Repeat parsing and processing of syntactic expressions 10000 times 
2415= Advanced demo to realize the assignment of internal variables 
2416= This is an example I pulled out from another script engine. There are a lot of contents, but the principle is only three steps 
2417= Pre declaration of assignment and post declaration of assignment 
2418= Cut expression body 
2419= We need to assign temporary variables separated by commas 
2420= Assignment found in expression 
2421= Variable hash storage structure, which can be stored in the hard disk 
2422= The op variable we use as the cache 
2423= For use 
2424= Dynamic variable 
2425= There are two ways to write here: C and Pascal. You can modify the remarks by yourself 
2426= Lexical parsing engine, taking C grammar as an example 
2427= Sourtp: = ttextparsing. Create ('myvar1 (* here is the note *), myvar2, myvar3: = 123 + 456 + '#39' variable: '#39' + dynamic ', tspascal)// Lexical parsing engine, taking C grammar as an example 
2428= sourTp := TTextParsing.Create('123+456+dynamic', tsPascal); //  Lexical parsing engine, taking C grammar as an example 
2429= 16 is the buff length of the hash. The larger the value, the faster the acceleration 
2430= The first step is to analyze the assignment symbols 
2431= The assignment symbol of Pascal is:= 
2432= Take the string as the cutting mark to cut the string with: = mark 
2433= This is not a string, but a character is used as a cutting mark to cut the character with 
2434= The assignment symbol of C is= 
2435= This is not a string, but a character is used as a cutting mark to cut the character with = 
2436= Dynamic multiplexing of myvar1 
2437= Step 2, if the assignment symbol is found 
2438= After cutting the leading and trailing spaces once, execute OP and assign values in batches 
2439= The third step is to reuse variables in expressions 
2440= Since the opcache mechanism is automated, we must clear it whenever we reuse variables with const 
2441= We need to tell the compiler the type of the variable 
2442= Myvar4 does not exist 
2443= Then we replace it with myvar2 
2444= Special symbolic function 
2445= All prefixes with @ @ symbols are treated as ASCII 
2446= ASCII with @ @ prefix can also have special symbols in the suffix, and the length of special symbols is not limited 
2447= For simple string expressions, we use the text format of C 
2713=%S user is offline
2714=Invalid expression
2715=Anonymous user
2717= After 1.5 seconds, check the offline status of the client 
2718= When the client is not offline, the syntax engine is used to calculate the expression result once 
2719= Write the feedback value to the delayed data structure, which is equivalent to outdata 
2720= Immediately feed back the calculation results to the client 
2721= Fog calculation simulation 
2722= Pause feedback 
2723= Delay engine, throw a 1.5 second execution time 
2724= Delayed throwing is to simulate the background thread or cross service calculation, and continue to feed back the results after the calculation is completed 
2740= Maximum load 
2753= Chinese people's own open source third-party development package 
2754= (C) Copyright 2001-2015 CnPack development team 
2757= This development package is open source free software. You can repair it in accordance with the release agreement of CnPack 
2758= Revise and reissue the program. 
2759= This development package was released in the hope that it would be useful, but there is no guarantee. Not even 
2760= Implied warranty for a particular purpose. For more details, see the CnPack publishing protocol. 
2761= You should have received a copy of the CnPack distribution agreement with the development package. If 
2762= Not yet, visit our website: 
2763= Website address: http://www.cnpack.org 
2764= E-mail: master@cnpack.org 
2765= This unit is rewritten based on md5.pas of Ronald L. Rivest. The following is the declaration of md5.pas: 
2780= Modified: love to eat pig head meat & flying Wang 2015-08-05 
2781= You can compare it with the original version to see what I have changed. 
2782= Idiots always think Delphi is different from other languages. 
2783= However, with the correct code, the results of various encryption and decryption are the same. 
2784= If you don't like hex format, you can return to Base64 format. 
2785= On xe7, you can use system.netencoding 
2786= Call system.netencoding.base64.encode (use the parameters of tbytes version); 
2791= User API function definition 
2792= *MD5 conversion of data blocks
|<PRE>
Const buffer - data block to be calculated
Count: uint32 - data block length
|</PRE> 
2793= *Output MD5 calculated value in hexadecimal format
|<PRE>
Digest: tmd5digest - specified MD5 calculated value
|</PRE> 
2794= *Compare whether the two MD5 calculated values are equal
|<PRE>
D1: tmd5digest - MD5 calculated value to be compared
D2: tmd5digest - MD5 calculated value to be compared
|</PRE> 
2795= *MD5 calculated value to string
|<PRE>
ADIG: tmd5digest - MD5 calculated value to be converted
|</PRE> 
2796= All encoding values are not assigned. The default value is utf8. 
2797= *MD5 transform the specified stream data
|<PRE>
Stream: tsstream - stream content to be calculated
Callback: tmd5calcprogressfunc - progress callback function, which is empty by default
|</PRE> 
2798= *MD5 conversion of specified file data
|<PRE>
Filename: String - the file name to calculate
Callback: tmd5calcprogressfunc - progress callback function, which is empty by default
|</PRE> 
2799= *Incoming plaintext and encryption key, MD5 encrypts and returns ciphertext,
Note: since the ciphertext may contain extended ASCII characters, in Delphi 2009 or above, please use
Variables of type tbytes receive the return value to avoid unnecessary Unicode conversion leading to decryption errors 
2800= *Pass in plaintext and encryption key, and MD5 encrypts and returns the ciphertext converted into hexadecimal 
2838= User API function implementation 
2839= MD5 conversion of data blocks 
2840= Output MD5 calculated value in hexadecimal format 
2841= Compare whether the two MD5 calculated values are equal 
2842= MD5 calculated value to string 
2843= SHA1 conversion of specified file data 
2844= Files larger than 2G may fail to map, and the flow method is adopted for cyclic processing 
2845= Perform MD5 calculation on the specified flow 
3020=%S (%s) login
3021=%S (%s) offline
3023=Tourist%.5D
3054= Log in to the hook and download a copy of the client configuration file from the database again 
3056= User already exists, polling registration 
3057= Complete registration and create basic user information 
3058= Local registration failed, and then go to remote polling 
